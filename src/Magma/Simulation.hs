{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable, MultiParamTypeClasses, FlexibleInstances, GeneralizedNewtypeDeriving, Arrows, GADTs, DataKinds, PolyKinds, TypeOperators, StandaloneDeriving, TypeFamilies, UndecidableInstances, ViewPatterns, PatternSynonyms, MultiParamTypeClasses, ScopedTypeVariables, LambdaCase, RankNTypes, FlexibleContexts #-}
module Magma.Simulation where

import Prelude hiding (id, (.), and, or, zip, foldr1, concat,sequence)
import Data.Traversable
import Data.Foldable hiding (and, or)
import Data.Functor
import Data.Bifoldable
import Data.Monoid
import Data.Type.Equality
import Control.Applicative
import Control.Arrow
import Control.Category
import Data.Functor.Identity
import Control.Monad.State hiding (sequence)
import Data.Proxy

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map

import qualified GHC.TypeLits

import Magma.Nat
import Magma.Vec
import Magma.Circuit

newtype SimulationM a = SimulationM { unSimulationM :: Identity a }
                      deriving (Functor, Applicative, Monad)

instance MonadCircuit SimulationM where
  data Wire SimulationM = WConst Bool
                        | WVec [Bool]
                        deriving(Eq, Ord, Show)
                                 
  addEquation (EAnd (WConst a) (WConst b))  = return $ WConst (a && b)
  addEquation (EOr (WConst a) (WConst b))   = return $ WConst (a || b)
  addEquation (EXor (WConst a) (WConst b))  = return $ WConst ((a || b) && not (a && b))
  addEquation (ENand (WConst a) (WConst b)) = return $ WConst (not (a && b))
  addEquation (ENot (WConst a))             = return $ WConst (not a)
  addEquation (EMux (WConst True) a b)      = return $ a
  addEquation (EMux (WConst False) a b)     = return $ b
  addEquation (ESelect (WVec v) i)          = return $ WConst (v !! i)


  constWire = WConst

  viewConstWire (WConst a) = Just a
  viewConstWire _          = Nothing

  -- reg f = Circuit . Kleisli $ \a -> do
  --   WWire w <- freshWire
  --   (w', b) <- runKleisli (unCircuit $ f (WWire w)) a
  --   modify $ \s -> s { circuitEquations = Map.insert w (EReg w') (circuitEquations s) }
  --   return b

  -- rom = Circuit . Kleisli $ \a -> do
  --   WWire w  <- freshWire
  --   modify $ \s -> s { circuitEquations = Map.insert w (ERom a) (circuitEquations s) }
  --   ws <- traverse
  --         (\i -> do
  --             WWire w' <- freshWire
  --             modify $ \s -> s { circuitEquations = Map.insert w' (ESelect (WWire w) i) (circuitEquations s) }
  --             return (WWire w')
  --         )
  --         indicesVec
  --   return ws

  -- ram f = Circuit . Kleisli $ \(ra, a) -> do
  --   WWire w  <- freshWire
  --   ws <- traverse
  --         (\i -> do
  --             w' <- freshWire
  --             return (i, w')
  --         )
  --         indicesVec
  --   (wa, wd, we, b) <- runKleisli (unCircuit $ f (fmap snd ws)) a
  --   modify $ \s -> s { circuitEquations = Map.insert w (ERam ra wa wd we) (circuitEquations s) }
  --   traverse
  --     (\(i, WWire w') -> do 
  --         modify $ \s -> s { circuitEquations = Map.insert w' (ESelect (WWire w) i) (circuitEquations s) }
  --     )
  --     ws
  --   return b

-- class CircuitIO a where
--   circuitIOFrom :: a -> [Wire]
--   circuitIOTo   :: [Wire] -> a
-- instance CircuitIO () where
--   circuitIOFrom () = []
--   circuitIOTo   [] = ()
-- instance CircuitIO Wire where
--   circuitIOFrom w = [w]
-- instance CircuitIO w => CircuitIO (Vec n w) where
--   circuitWires = foldMap circuitWires
-- instance (CircuitIO a, CircuitIO b) => CircuitIO (a, b) where
--   circuitWires = bifoldMap circuitWires circuitWires

-- class CircuitIO a => CircuitInput a where
--   circuitInput  :: String -> a
-- instance CircuitInput () where
--   circuitInput _ = ()
-- instance CircuitInput Wire where
--   circuitInput s = WInput (s ++ "w")
-- instance (GenerateVec n, CircuitInput w) => CircuitInput (Vec n w) where
--   circuitInput s = fmap (\i -> circuitInput (s ++ "i" ++ show i)) $ indicesVec
-- instance (CircuitInput a, CircuitInput b) => CircuitInput (a, b) where
--   circuitInput s = (circuitInput (s ++ "a"), circuitInput (s ++ "b"))

-- -- TODO : circuit input / output
-- -- | 'runCircuit' produces a string describing the netlist generated by the circuit
runSimulation :: Circuit SimulationM a b -> [a] -> [b]
runSimulation (Circuit (Kleisli c)) as = runIdentity $ do
  foldM (\bs a -> do
            b <- unSimulationM (c a)
            return (b : bs)
        ) [] as
