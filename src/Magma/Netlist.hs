{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable, MultiParamTypeClasses, FlexibleInstances, GeneralizedNewtypeDeriving, Arrows, GADTs, DataKinds, PolyKinds, TypeOperators, StandaloneDeriving, TypeFamilies, UndecidableInstances, ViewPatterns, PatternSynonyms, MultiParamTypeClasses, ScopedTypeVariables, LambdaCase, RankNTypes, FlexibleContexts #-}
module Magma.Netlist where

import Prelude hiding (id, (.), and, or, zip, foldr1, concat,sequence)
import Data.Traversable
import Data.Foldable hiding (and, or)
import Data.Functor
import Data.Bifoldable
import Data.Monoid
import Data.Type.Equality
import Control.Applicative
import Control.Arrow
import Control.Category
import Data.Functor.Identity
import Control.Monad.State hiding (sequence)
import Data.Proxy

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map

import qualified GHC.TypeLits

import Magma.Nat
import Magma.Vec
import Magma.Circuit

data CircuitState = CircuitState
                    { circuitFresh     :: Int
                    , circuitEquations :: Map Int (Equation NetlistM)
                    }

emptyCircuitState :: CircuitState
emptyCircuitState = CircuitState 0 Map.empty

newtype NetlistM a = NetlistM { unNetlistM :: State CircuitState a }
                   deriving (Functor, Applicative, Monad, MonadState CircuitState)

instance MonadCircuit NetlistM where
  data Wire NetlistM = WWire Int
                     | WConst Bool
                     | WInput String
                     deriving(Eq, Ord)
                                 
  addEquation e = do
    WWire w <- freshWire
    modify $ \s -> s { circuitEquations = Map.insert w e (circuitEquations s) }
    return (WWire w)

  constWire = WConst

  viewConstWire (WConst a) = Just a
  viewConstWire _          = Nothing

  reg f = Circuit . Kleisli $ \a -> do
    WWire w <- freshWire
    (w', b) <- runKleisli (unCircuit $ f (WWire w)) a
    modify $ \s -> s { circuitEquations = Map.insert w (EReg w') (circuitEquations s) }
    return b

  rom = Circuit . Kleisli $ \a -> do
    WWire w  <- freshWire
    modify $ \s -> s { circuitEquations = Map.insert w (ERom a) (circuitEquations s) }
    ws <- traverse
          (\i -> do
              WWire w' <- freshWire
              modify $ \s -> s { circuitEquations = Map.insert w' (ESelect (WWire w) i) (circuitEquations s) }
              return (WWire w')
          )
          indicesVec
    return ws

  ram f = Circuit . Kleisli $ \(ra, a) -> do
    WWire w  <- freshWire
    ws <- traverse
          (\i -> do
              w' <- freshWire
              return (i, w')
          )
          indicesVec
    (wa, wd, we, b) <- runKleisli (unCircuit $ f (fmap snd ws)) a
    modify $ \s -> s { circuitEquations = Map.insert w (ERam ra wa wd we) (circuitEquations s) }
    traverse
      (\(i, WWire w') -> do 
          modify $ \s -> s { circuitEquations = Map.insert w' (ESelect (WWire w) i) (circuitEquations s) }
      )
      ws
    return b

freshWire :: NetlistM (Wire NetlistM)
freshWire = do
  i <- circuitFresh <$> get
  modify $ \s -> s { circuitFresh = i + 1 }
  return (WWire i)

-- class CircuitIO a where
--   circuitWires :: a -> [Wire]
-- instance CircuitIO () where
--   circuitWires () = []
-- instance CircuitIO Wire where
--   circuitWires w = [w]
-- instance CircuitIO w => CircuitIO (Vec n w) where
--   circuitWires = foldMap circuitWires
-- instance (CircuitIO a, CircuitIO b) => CircuitIO (a, b) where
--   circuitWires = bifoldMap circuitWires circuitWires

-- class CircuitIO a => CircuitInput a where
--   circuitInput  :: String -> a
-- instance CircuitInput () where
--   circuitInput _ = ()
-- instance CircuitInput Wire where
--   circuitInput s = WInput (s ++ "w")
-- instance (GenerateVec n, CircuitInput w) => CircuitInput (Vec n w) where
--   circuitInput s = fmap (\i -> circuitInput (s ++ "i" ++ show i)) $ indicesVec
-- instance (CircuitInput a, CircuitInput b) => CircuitInput (a, b) where
--   circuitInput s = (circuitInput (s ++ "a"), circuitInput (s ++ "b"))

-- -- TODO : circuit input / output
-- -- | 'runCircuit' produces a string describing the netlist generated by the circuit
-- runCircuit :: (CircuitInput a, CircuitIO b) => Circuit a b -> String
-- runCircuit (Circuit c) =
--   let isConstWire (WConst _) = True
--       isConstWire _          = False
--       input = circuitInput ""
--       (output, circuitEquations -> eqs) = flip runState emptyCircuitState . unCircuitMonad $ runKleisli c input
--       inputs     = filter (not.isConstWire) $ circuitWires input
--       outputs    = filter (not.isConstWire) $ circuitWires output
--       vars       = Map.keys eqs
--       varname x  = "v" ++ show x
--       commasep [] = ""
--       commasep xs = foldr1 (\a b -> a ++ ", " ++ b) xs
--       printWire (WWire a)  = varname a
--       printWire (WInput s) = "i" ++ s
--       printWire (WConst False) = "0"
--       printWire (WConst True)  = "1"
--       printEquation (EAnd a b)     = "AND " ++ printWire a ++ " " ++ printWire b
--       printEquation (EOr a b)      = "OR " ++ printWire a ++ " " ++ printWire b
--       printEquation (EXor a b)     = "XOR " ++ printWire a ++ " " ++ printWire b
--       printEquation (ENand a b)    = "NAND " ++ printWire a ++ " " ++ printWire b
--       printEquation (ENot a)       = "NOT " ++ printWire a
--       printEquation (EMux a b c)   = "MUX " ++ printWire a ++ " " ++ printWire b ++ " " ++ printWire c
--       -- need to concat 28 wires
-- --      printEquation (ERom a)       = "ROM " ++ printWire a
-- --      printEquation (ERam a b c d) = "RAM " ++ printWire a ++ " " ++ printWire b ++ " " ++ printWire c ++ " " ++ printWire d
--       printEquation (ESelect a b)  = "SELECT " ++ show b ++ " " ++ printWire a
--       printEquation (EReg a)       = "REG " ++ printWire a
--   in concat
--      [ "INPUT "
--      , commasep (printWire <$> inputs)
--      , "\nOUTPUT "
--      , commasep (printWire <$> outputs)
--      , "\nVAR "
--      , commasep (fmap varname vars ++ fmap printWire inputs ++ fmap printWire outputs)
--      , "\nIN\n"
--      , concat (fmap (\(w, e) -> varname w ++ " = " ++ printEquation e ++ "\n") (Map.toList eqs)) 
--      ] 

